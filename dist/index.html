<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Radfoam Demo</title>
  </head>

  <body>
    <script id="shader-fs" type="x-shader/x-fragment">#version 300 es
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp usampler2D;

// Inputs from the vertex shader
in vec2 v_uv;
in vec2 v_ray;

// Output to the framebuffer
out vec4 fragColor;

// Uniforms
uniform sampler2D _MainTex;
uniform sampler2D _attr_tex;
uniform sampler2D _positions_tex;
uniform sampler2D _adjacency_diff_tex; 
uniform sampler2D _adjacency_tex;
uniform usampler2D _offsets_tex;

// Uniforms for raycasting logic
uniform float _FisheyeFOV;
uniform mat4 _Camera2WorldMatrix;
uniform mat4 _InverseProjectionMatrix;
uniform uint _start_index;

// Texel size uniform variables
// Assuming 4096 is the fixed width for the buffer textures.
uniform vec2 _positions_tex_TexelSize;
uniform vec2 _adjacency_tex_TexelSize;
uniform vec2 _offsets_tex_TexelSize;

// Constants
const float PI = 3.14159265;
const uint CHUNK_SIZE = 6u;
const uint BUFFER_WIDTH = 4096u;
const uint INVALID_FACE = 0xFFFFFFFFu;

// Helper Functions

vec2 index_to_tex_buffer(uint i, vec2 texel_size, uint width) {
    uint y = i / width;
    uint x = i % width;
    return vec2((float(x) + 0.5) * texel_size.x, (float(y) + 0.5) * texel_size.y);
}

uint offset_buff(uint i) {
    // NOTE: Texel width is 1 since this is R32UI.
    vec2 uv = index_to_tex_buffer(i, _offsets_tex_TexelSize, BUFFER_WIDTH);
    return texture(_offsets_tex, uv).r;
}

vec3 positions_buff(uint i) {
    vec2 uv = index_to_tex_buffer(i, _positions_tex_TexelSize, BUFFER_WIDTH);
    return textureLod(_positions_tex, uv, 0.0).xyz; 
}

vec4 attrs_buff(uint i) {
    vec2 uv = index_to_tex_buffer(i, _positions_tex_TexelSize, BUFFER_WIDTH);
    return textureLod(_attr_tex, uv, 0.0);
}

uint adjacency_buffer(uint i) {
    vec2 uv = index_to_tex_buffer(i, _adjacency_tex_TexelSize, BUFFER_WIDTH);
    float val = textureLod(_adjacency_tex, uv, 0.0).r;
    return uint(val + 0.5); // Read float and cast to uint (adding 0.5 for rounding)
}

vec3 adjacency_diff_buffer(uint i) {
    vec2 uv = index_to_tex_buffer(i, _adjacency_tex_TexelSize, BUFFER_WIDTH);
    return textureLod(_adjacency_diff_tex, uv, 0.0).rgb;
}

void GetCameraRayFisheye(vec2 uv, float fov, out vec3 ray_origin, out vec3 ray_direction)
{
    ray_origin = (_Camera2WorldMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;

    float theta = atan(uv.y, uv.x); // atan2 in HLSL is typically atan(y, x) in GLSL for vectors
    float phi = sqrt(dot(uv, uv)) * fov * (1.0 / 360.0) * 2.0 * PI;

    vec3 local_dir = sin(phi) * cos(theta) * vec3(1.0, 0.0, 0.0)
                   + sin(phi) * sin(theta) * vec3(0.0, 1.0, 0.0)
                   + cos(phi) * vec3(0.0, 0.0, -1.0);

    ray_direction = (_Camera2WorldMatrix * vec4(local_dir, 0.0)).xyz;

    if (phi >= PI) {
        ray_direction = vec3(0.0, 0.0, 0.0);
    }
}

void main()
{
    vec4 src_color = texture(_MainTex, v_uv);
    
    // HLSL's Ray struct members: origin, direction
    vec3 ray_origin;
    vec3 ray_direction;
    GetCameraRayFisheye(v_ray, _FisheyeFOV, ray_origin, ray_direction);
    
    if (dot(ray_direction, ray_direction) == 0.0) {
        fragColor = src_color; // fisheye fov too large
        return; 
    }
    
    ray_direction = normalize(ray_direction);

    float scene_depth = 10000.0;
    
    vec3 diffs[int(CHUNK_SIZE)]; 

    // tracing state
    uint cell = _start_index;
    float transmittance = 1.0;
    vec3 color = vec3(0.0, 0.0, 0.0);
    float t_0 = 0.0;

    int i = 0;
    // Loop max 200 iterations or until transmittance is too low
    for (i = 0; i < 200 && transmittance > 0.05; i++) {
        vec3 cell_data = positions_buff(cell);

        // Previously read from cell_data.w, now seperate buffer
        uint adj_from = (cell > 0u) ? (offset_buff(cell - 1u)) : 0u;

        uint adj_to = (offset_buff(cell));
        
        vec4 attrs = attrs_buff(cell);

        float t_1 = scene_depth;
        uint next_face = INVALID_FACE;

        uint faces = adj_to - adj_from;

        // Testing tracing without crashing webgl
        if (faces == 0u) {
            fragColor = vec4(0.0, 1.0, 0.0, 1.0); 
            return; 
        }

        for (uint f = 0u; f < faces; f += CHUNK_SIZE) {

            for (uint a1 = 0u; a1 < CHUNK_SIZE; a1++) {
                if (f + a1 < faces) {
                     diffs[int(a1)] = adjacency_diff_buffer(adj_from + f + a1).xyz;
                } else {
                     diffs[int(a1)] = vec3(0.0);
                }
            }
            
            for (uint a2 = 0u; a2 < CHUNK_SIZE; a2++) {
                vec3 diff = diffs[int(a2)]; // half3 in HLSL is just vec3 in highp GLSL
                float denom = dot(diff, ray_direction);
                vec3 mid = cell_data.xyz + diff * 0.5;
                float t = dot(mid - ray_origin, diff) / denom;
                
                // bool valid = denom > 0 && t < t_1 && t > t_0 && f + a2 < faces;
                bool valid = (denom > 0.0) && (t < t_1) && (t > t_0) && (f + a2 < faces);
                
                if (valid) {
                    t_1 = t;
                    next_face = adj_from + f + a2;
                }
            }
        }

        float density = attrs.w;
        float alpha = 1.0 - exp(-density * (t_1 - t_0));
        float weight = transmittance * alpha;

        color += attrs.rgb * weight;
        transmittance *= (1.0 - alpha);

        if (next_face == INVALID_FACE) {
            break;
        }

        cell = adjacency_buffer(next_face);
        t_0 = t_1;
    }

    fragColor = vec4(mix(color, src_color.rgb, transmittance), 1.0);
}
    </script>

    <script id="shader-vs" type="x-shader/x-vertex">#version 300 es
// Vertex attributes (like Unity's 'blit_data' struct)
in vec4 a_position; // Corresponds to POSITION
in vec2 a_uv;       // Corresponds to TEXCOORD0

// Outputs to the fragment shader (like Unity's 'blit_v2f' struct)
out vec2 v_uv;      // Corresponds to TEXCOORD0
out vec2 v_ray;     // Corresponds to TEXCOORD1

// Uniforms (for screen space setup)
uniform vec4 u_ScreenParams; // .z = width, .w = height (similar to _MainTex_TexelSize.zw)
uniform mat4 unity_ObjectToClipPos; // Unity's equivalent of 'UnityObjectToClipPos'

void main()
{
    // Corresponds to o.vertex = UnityObjectToClipPos(v.vertex);
    gl_Position = unity_ObjectToClipPos * a_position;
    
    v_uv = a_uv;

    v_ray = a_uv * 2.0 - 1.0;
    
    v_ray.x *= u_ScreenParams.z / u_ScreenParams.w;
}
    </script>

    <h1 id="loading-msg">PLY file is loading...</h1>
    <canvas id="gl-canvas" width="480" height="270"></canvas>
    <script src="webgl-utils.js"></script>
    <script src="main.js" type="text/javascript"></script>
  </body>
</html>